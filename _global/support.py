"""
Provide a basic CLI for managing a set of EPICS support modules
"""

import os
import re
import subprocess
from pathlib import Path
from typing import List, Optional
from jinja2 import Template

import typer

# note requirement for enviroment variable EPICS_BASE
EPICS_BASE = Path(str(os.getenv("EPICS_BASE")))
EPICS_ROOT = Path(str(os.getenv("EPICS_ROOT")))

# all support modules will reside under this directory
SUPPORT = Path(str(os.getenv("SUPPORT")))
# the global RELEASE file which lists all support modules
RELEASE = Path(f"{SUPPORT}/configure/RELEASE")
# a bash script to export the macros defined in RELEASE as environment vars
RELEASE_SH = Path(f"{SUPPORT}/configure/RELEASE.shell")
# global MODULES file used to determine order of build
MODULES = Path(f"{SUPPORT}/configure/MODULES")
# Folder containing Makefile.jinja
MAKE_FOLDER = Path(str(os.getenv("IOC"))) / "iocApp/src"
# Folder containing ibek support scripts
SCRIPTS_FOLDER = Path("/workspaces/ibek-support")

# find macro name and macro value in a RELEASE file
# only include values with at least one / (attempt to match filepaths only)
PARSE_MACROS = re.compile(r"^([A-Z_a-z0-9]*)\s*=\s*(.*/.*)$", flags=re.M)
# like the above but allows any value including blank
PARSE_MACROS_NULL = re.compile(r"^([A-Z_a-z0-9]*)\s*=(.*)$", flags=re.M)
# turn RELEASE macros into bash macros
SHELLIFY_FIND = re.compile(r"\$\(([^\)]*)\)")
SHELLIFY_REPLACE = r"${\1}"


cli = typer.Typer()


LOCAL_RELEASE_TEMPLATE = """#
# RELEASE.local generated by:
# https://github.com/epics-containers/ibek-support/tree/main/_global/support.py
#

SUPPORT=/epics/support
EPICS_BASE=/epics/epics-base

# Further support modules paths will be added below

"""


@cli.command()
def fix_release(
    name: str = typer.Argument(..., help="the name of the support module"),
    macro: Optional[str] = typer.Argument(None, help="Macro name for the module"),
    path: Optional[Path] = typer.Argument(None, help="The path to the support module"),
):
    """
    prepare the configure RELEASE files to build a support module
    inside an epics-containers build

    """
    if macro is None:
        macro = name.upper()
    if path is None:
        path = EPICS_ROOT / "support" / name

    # add or replace the macro for this module in the global RELEASE file
    with RELEASE.open("r") as stream:
        lines = stream.readlines()
    outlines = []
    replaced = False
    for line in lines:
        if line.startswith(f"{macro}="):
            outlines.append(f"{macro}={path}\n")
            replaced = True
        else:
            outlines.append(line)
    if not replaced:
        outlines.append(f"{macro}={path}\n")

    with RELEASE.open("w") as stream:
        stream.writelines(outlines)

    # save the macros and paths from the global release file
    global_release_files_macros = {}
    for match in PARSE_MACROS_NULL.findall("".join(outlines)):
        global_release_files_macros[match[0]] = match[1]

    # now write a RELEASE.local with the paths this module uses
    configure_folder = path / "configure"
    release_files = configure_folder.glob("RELEASE*")
    release_files_macros = {}

    # iterate over all release files and find all macros they use
    for rel in release_files:
        text = rel.read_text()
        for match in PARSE_MACROS.findall(text):
            release_files_macros[match[0]] = match[1]

    # write out values for the modules macros into RELEASE.local
    local = configure_folder / "RELEASE.local"
    local_text = LOCAL_RELEASE_TEMPLATE

    for macro, path in release_files_macros.items():
        # macros with EPICS base in their path are not support modules
        if "EPICS_BASE" in path:
            continue
        if macro not in global_release_files_macros:
            raise ValueError(f"missing dependency {macro} for module {name}")
        local_text += f"{macro}={global_release_files_macros[macro]}\n"
    local.write_text(local_text)

    # make sure this module uses RELEASE.local
    verify_release_includes_local(configure_folder)

    do_dependencies()


def verify_release_includes_local(configure_folder: Path):
    """
    Make sure that a module uses RELEASE.local

    a git dirtying patch is required if not.
    """
    fname = "RELEASE.local"

    release = configure_folder / "RELEASE"

    text = release.read_text()

    if fname in text:
        print(f"OK - {configure_folder}/RELEASE references RELEASE.local")
    else:
        print(f"WARNING: {configure_folder}/RELEASE does not include RELEASE.local")
        print(f"WARNING: patching {configure_folder}/RELEASE")
        text += "# PATCHED BY IBEK-SUPPORT\n"
        text += "-include $(TOP)/configure/RELEASE.local\n"
        release.write_text(text)


def do_dependencies():
    # parse the global release file
    global_release_paths = {}
    text = RELEASE.read_text()
    for match in PARSE_MACROS_NULL.findall(text):
        global_release_paths[match[0]] = match[1]

    # generate the MODULES file for inclusion into the root Makefile
    # it simply defines a variable to hold each of the support module
    # directories in the order they are presented in RELEASE, except that
    s = str(SUPPORT)
    print(s, global_release_paths.values())
    paths = [
        path[len(s) + 1 :]
        for path in global_release_paths.values()
        if path.startswith(s)
    ]
    if "IOC" in global_release_paths:
        paths.append(global_release_paths["IOC"])
    mod_list = f'MODULES := {" ".join(paths)}\n'
    MODULES.write_text(mod_list)

    # generate RELEASE.sh file for inclusion into the ioc launch shell script.
    # This adds all module paths to the environment and also adds their db
    # folders to the database search path env variable EPICS_DB_INCLUDE_PATH
    release_sh = []
    for module, path in global_release_paths.items():
        release_sh.append(f'export {module}="{path}"')

    db_paths = [
        f"{path}/db" for path in global_release_paths.values() if path.startswith(s)
    ]
    db_path_list = ":".join(db_paths)
    release_sh.append(f'export EPICS_DB_INCLUDE_PATH="{db_path_list}"')

    shell_text = "\n".join(release_sh) + "\n"
    shell_text = SHELLIFY_FIND.sub(SHELLIFY_REPLACE, shell_text)
    RELEASE_SH.write_text(shell_text)


@cli.command()
def makefile():
    """
    get the dbd and lib files from all support modules and generate
    iocApp/src/Makefile from iocApp/src/Makefile.jinja
    """

    # use modules file to get a list of all support module folders
    # in the order of build (and hence dependency)
    modules = MODULES.read_text().split()[2:]
    # remove the IOC folder from the list
    if "IOC" in modules:
        modules.remove("IOC")

    # get all the dbd and lib files from each support module
    dbds = []
    libs = []
    for module in modules:
        folder = SCRIPTS_FOLDER / module
        dbd_file = folder / "dbd"
        if dbd_file.exists():
            dbds.extend(dbd_file.read_text().split())
        lib_file = folder / "lib"
        if lib_file.exists():
            libs.extend(lib_file.read_text().split())

    # generate the Makefile from the template
    template = Template((MAKE_FOLDER / "Makefile.jinja").read_text())
    # libraries are listed in reverse order of dependency
    libs.reverse()
    text = template.render(dbds=dbds, libs=libs)

    with (MAKE_FOLDER / "Makefile").open("w") as stream:
        stream.write(text)


@cli.command()
def not_required(
    macros: List[str] = typer.Argument(..., help="Macro names for the modules")
):
    """
    Allow a support module to declare that it does not require another
    support module. (but that it will use it if already installed)
    """
    with RELEASE.open("r") as stream:
        original = lines = stream.readlines()

    for macro in macros:
        for line in lines:
            if line.startswith(f"{macro}="):
                # this macro is already in global RELEASE
                break
        else:
            print(f"MACRO {macro}")
            # add in a null entry for this macro
            lines += f"{macro}=\n"

    with RELEASE.open("w") as stream:
        lines = stream.writelines(lines)


if __name__ == "__main__":
    cli()
    # for quick debugging of e.g. dependencies function change to:
    # cli(["dependencies"])
